var __index = {"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":"<p><code>SimPYson</code> is a Python package developed to streamline the use of SIMPSON, a simulation software for solid-state NMR. Born out of the frustration of trying to learn and use SIMPSON on my own, SimPYson aims to simplify the process of converting DFT calculation results into SIMPSON input files and read Simpson simulation, all within python</p>"},{"location":"index.html#current-features","title":"Current features \ud83e\udd0c","text":"<ul> <li>Convert results from DFT calculations (e.g., CASTEP, Quantum Espresso, VASP) into SIMPSON input files.</li> <li>Read and process output files from SIMPSON simulations.</li> <li>Provide ready-to-use templates for common SIMPSON NMR experiments, such as 90-degree pulse and no-pulse.</li> </ul>"},{"location":"index.html#why-choose-simpyson","title":"Why choose SimPYson? \ud83d\ude4e\u200d\u2642\ufe0f","text":"<p>No particular reason. One possible advantage lies in its seamless integration with other Python packages, making it easy to incorporate into your existing Python workflow. However, depending on your needs/taste, there are a few alternatives that may better suit you, hera are some examples:</p> <ul> <li>Simplot: From the developers of Simpson offers a user-friendly interface to analyze the results.</li> <li>Simview: From Zden\u011bk To\u0161ner (Simpson dev) provides a GUI to run SIMPSON simulations and plot results within a clean, intuitive interface</li> <li>EasyNMR: A cloud-based platform that allows you to run and analyze SIMPSON simulations remotely.</li> </ul>"},{"location":"index.html#future","title":"Future","text":"<p>We are open to suggestions.</p>"},{"location":"about/changelog.html","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"about/changelog.html#011","title":"[0.1.1]","text":"<ul> <li>Added a GUI for Simpyson</li> <li>Implemented FID to SPE convertion within GUI</li> <li>Implemented Hz to ppm convertion within GUI</li> </ul>"},{"location":"about/changelog.html#010","title":"[0.1.0]","text":""},{"location":"about/changelog.html#added","title":"Added","text":"<ul> <li>Tutorial on converting DFT structures to Simpson simulations.</li> <li>Tutorial on reading and processing Simpson simulation results.</li> <li>Added isotopes data to convert from Hz to ppm.</li> <li>Added <code>SimpSim</code> class to prepare Simpson input files.</li> <li>Added <code>read_vasp</code> to convert VASP NMR tensors into a format readable by Soprano.</li> <li>Templates for 90-degree pulse <code>pulse_90</code> and no-pulse <code>no_pulse</code> experiments.</li> </ul>"},{"location":"about/changelog.html#001","title":"[0.0.1]","text":""},{"location":"about/changelog.html#added_1","title":"Added","text":"<ul> <li>The initial release!</li> </ul>"},{"location":"about/citation.html","title":"Citing simPYson","text":"<p>If you use <code>SimPYson</code> in your work, please consider citing all the software that makes it possible:</p> <ul> <li>SIMPSON: https://doi.org/10.1016/j.jmr.2011.09.008, https://doi.org/10.1016/j.jmr.2014.07.002, and https://doi.org/10.1016/bs.arnmr.2019.12.001</li> <li>ASE: https://doi.org/10.1088/1361-648X/aa680e</li> <li>Soprano: Acknowledge CCPNC.<ul> <li>This work was facilitated by software tools (specifically Soprano) developed by the Collaborative Computing Project for NMR Crystallography, funded by EPSRC grant EP/T026642/1.</li> </ul> </li> <li>SimPYson: https://doi.org/10.5281/zenodo.14041918</li> </ul> <p>For the most accurate references, please refer to each software\u2019s official website or documentation for citation details.</p>"},{"location":"about/contributors.html","title":"People","text":"<p>SimPYson is currently maintained by Carlos, M\u00e1rcio and Daniel as part of NUTS.</p>"},{"location":"about/contributors.html#active-maintainers","title":"Active Maintainers","text":"<p>The currently active maintainers are as follows:</p> <ul> <li>Carlos Bornes</li> <li>M\u00e1rcio Soares:</li> <li>Daniel Pereira:</li> </ul>"},{"location":"about/contributors.html#contributors","title":"Contributors","text":"<p>Additional contributions were made by the individuals listed here.</p>"},{"location":"about/contributors.html#inspiration","title":"Inspiration","text":"<p>Some project that served as inspiration for SimPYson are:</p> <ul> <li> <p>Quantum Accelerators Python package template created by Andrew S. Rosen.</p> </li> <li> <p>Soprano created by CCP-NC, Simone Sturniolo and currently maintained by Kane Shenton.</p> </li> </ul>"},{"location":"about/license.html","title":"License","text":"LICENSE.md<pre><code>MIT License\n\nCopyright (c) 2024\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"installation/install.html","title":"Installation","text":"<p>If you have Python and pip installed, you can easily install SimPYson with the following command:</p> <pre><code>pip install git+https://github.com/nuts-org/simpyson.git\n</code></pre> <p>All dependecies are installed automatically.</p> <p>To verify that the package has been installed successfully, open a Python console and run:</p> <pre><code>import simpyson\n</code></pre>"},{"location":"reference/SUMMARY.html","title":"SUMMARY","text":"<ul> <li>simpyson<ul> <li>cli</li> <li>converter</li> <li>gui</li> <li>io</li> <li>simpy</li> <li>templates</li> <li>utils</li> </ul> </li> </ul>"},{"location":"reference/simpyson/cli.html","title":"cli","text":""},{"location":"reference/simpyson/converter.html","title":"converter","text":""},{"location":"reference/simpyson/converter.html#simpyson.converter.hz2ppm","title":"hz2ppm","text":"<pre><code>hz2ppm(hz, b0, nucleus, isotope_file=None)\n</code></pre> <p>Convert Hz values to ppm values.</p> <p>Args:     hz (numpy.ndarray): Frequency values in Hz     b0 (str): Magnetic field strength (e.g., '400MHz' or '9.4T')     nucleus (str): Nucleus type (e.g., '1H' or '13C')     isotope_file (str, optional): Path to isotope data file. If None, uses default.</p> <p>Returns:     numpy.ndarray: Chemical shift values in ppm</p> <p>Raises:     ValueError: If B0 unit is invalid or nucleus not found</p> Source code in <code>simpyson/converter.py</code> <pre><code>def hz2ppm(hz, b0, nucleus, isotope_file=None):\n    \"\"\"\n    Convert Hz values to ppm values.\n\n    Args:\n        hz (numpy.ndarray): Frequency values in Hz\n        b0 (str): Magnetic field strength (e.g., '400MHz' or '9.4T')\n        nucleus (str): Nucleus type (e.g., '1H' or '13C')\n        isotope_file (str, optional): Path to isotope data file. If None, uses default.\n\n    Returns:\n        numpy.ndarray: Chemical shift values in ppm\n\n    Raises:\n        ValueError: If B0 unit is invalid or nucleus not found\n    \"\"\"\n\n    larmor_freq = get_larmor_freq(b0, nucleus, isotope_file)\n\n    ppm = hz / np.abs(larmor_freq)\n\n    return ppm\n</code></pre>"},{"location":"reference/simpyson/converter.html#simpyson.converter.ppm2hz","title":"ppm2hz","text":"<pre><code>ppm2hz(ppm, b0, nucleus, isotope_file=None)\n</code></pre> <p>Convert ppm values to Hz values.</p> <p>Args:     ppm (numpy.ndarray): Chemical shift values in ppm     b0 (str): Magnetic field strength (e.g., '400MHz' or '9.4T')     nucleus (str): Nucleus type (e.g., '1H' or '13C')     isotope_file (str, optional): Path to isotope data file. If None, uses default.</p> <p>Returns:     numpy.ndarray: Frequency values in Hz</p> <p>Raises:     ValueError: If B0 unit is invalid or nucleus not found</p> Source code in <code>simpyson/converter.py</code> <pre><code>def ppm2hz(ppm, b0, nucleus, isotope_file=None):\n    \"\"\"\n    Convert ppm values to Hz values.\n\n    Args:\n        ppm (numpy.ndarray): Chemical shift values in ppm\n        b0 (str): Magnetic field strength (e.g., '400MHz' or '9.4T')\n        nucleus (str): Nucleus type (e.g., '1H' or '13C')\n        isotope_file (str, optional): Path to isotope data file. If None, uses default.\n\n    Returns:\n        numpy.ndarray: Frequency values in Hz\n\n    Raises:\n        ValueError: If B0 unit is invalid or nucleus not found\n    \"\"\"\n\n    larmor_freq = get_larmor_freq(b0, nucleus, isotope_file)\n\n    hz = ppm * np.abs(larmor_freq) \n\n    return hz\n</code></pre>"},{"location":"reference/simpyson/converter.html#simpyson.converter.read_vasp","title":"read_vasp","text":"<pre><code>read_vasp(file, format)\n</code></pre> <p>This function reads NMR data from a VASP OUTCAR file.</p> <p>Args:     file (str): The path to the VASP OUTCAR file.     format (str): The format of the VASP OUTCAR file.</p> <p>Returns:     ase.Atoms: The Atoms object with the NMR data.</p> <p>Example:     reader = read_vasp('OUTCAR', 'vasp-out')</p> Source code in <code>simpyson/converter.py</code> <pre><code>def read_vasp(file, format):\n    \"\"\"\n    This function reads NMR data from a VASP OUTCAR file.\n\n    Args:\n        file (str): The path to the VASP OUTCAR file.\n        format (str): The format of the VASP OUTCAR file.\n\n    Returns:\n        ase.Atoms: The Atoms object with the NMR data.\n\n    Example:\n        reader = read_vasp('OUTCAR', 'vasp-out')\n    \"\"\"\n    filename = ase.io.read(file, format=format)\n    n_atoms = filename.get_global_number_of_atoms()\n    np.set_printoptions(suppress=True)\n    efg = []\n    sym_tensor = []\n    const_shield = []\n    core_shield_dict = []\n    ms = []\n    volume = None\n    with open(file, 'r') as outcar:\n        lines = outcar.readlines()\n        #Find lines with specific header\n        for line in lines:\n            if line.find(\"Electric field gradients (V/A^2)\") != -1:\n                idx_header1 = lines.index(line) #efg\n            if line.find(\"SYMMETRIZED TENSORS\") != -1:\n                idx_header2 = []\n                idx_header2.append(lines.index(line)) #sym tensor - need to take second one (unsym. tensors)\n            if line.find(\"G=0 CONTRIBUTION TO CHEMICAL SHIFT\") != -1:\n                idx_header3 = lines.index(line) #constant shielding\n            if line.find('Core NMR properties') != -1:\n                idx_header4 = lines.index(line) #core NMR prop - depends on atom type\n            if line.find(\"Core contribution to magnetic susceptibility:\") != -1:\n                val = line.split()[5]\n                exp = line.split()[6][-2:]\n                mag_sus = float(val)*10**int(exp)\n            if line.find(\"volume of cell\") != -1 and volume is None:\n                volume = float(line.split()[4])\n\n        chi_fact = 3.0/8.0/np.pi*volume*6.022142e23/1e24 # Conversion factor for magnetic susceptibility\n\n        #Calculate tensors for every atoms\n        for i in range(n_atoms):\n            grad = (lines[idx_header1+4+i]).split()[1:] # V_xx, V_yy, V_zz, V_xy, V_xz, V_yz\n            matrix = np.array([[grad[0],grad[3],grad[4]],   #xx xy xz\n                               [grad[3],grad[1],grad[5]],   #xy yy yz\n                               [grad[4],grad[5],grad[2]]])  #xz yz zz\n            efg.append(matrix)\n\n        for i in range(n_atoms*4):\n            if i % 4 != 0:\n                sym=lines[idx_header2[-1] + i + 1].split()\n                sym_tensor.append(lines[idx_header2[-1] + i + 1].split())\n\n        # Newer version of VASP 6.4.1\n        if lines[idx_header3 + 1].strip() == \"using pGv susceptibility, excluding core contribution\":\n            start_idx = idx_header3 + 5\n        # Older version of VASP\n        else:\n            start_idx = idx_header3 + 4\n\n        for i in range(3):\n            const_shield.append((lines[start_idx + i]).split()[1:])\n\n        for i in range(len(np.unique(filename.get_chemical_symbols()))):\n            core_shield_dict.append((lines[idx_header4 + 4 + i]).split()[1:])\n        core_shield_dict = dict((k[0], float(k[1:][0])) for k in core_shield_dict)\n        core_shield = []\n\n        for i in filename.get_chemical_symbols():\n            core_shield.append(core_shield_dict[i])\n\n    #Process results\n    efg = np.array(efg,dtype=float) #resulting EFG matrix\n    efg = efg * 1e20 / const.physical_constants[\"atomic unit of electric field gradient\"][0]\n    sym_tensor = np.split(np.array(sym_tensor,dtype=float), n_atoms) #symmetry tensors\n    const_shield = np.array(const_shield, dtype=float) #constant shielding of the lattice\n    core_shield = np.array(core_shield,dtype=float) #core shielding depending on atom type\n\n    for i in range(n_atoms):\n        core_diag = np.diag(core_shield[i] * np.ones(3))\n        ms_tensor = sym_tensor[i] + const_shield + core_diag + mag_sus/chi_fact*1e6*np.eye(3) #calculating MS tensor\n        ms.append(-ms_tensor)  # calculating MS tensors\n    ms=np.array(np.array(ms).tolist(),dtype=float) #processing MS tensor to work with ase\n\n    filename.set_array('efg', efg)\n    filename.set_array('ms', ms)\n\n    return filename\n</code></pre>"},{"location":"reference/simpyson/gui.html","title":"gui","text":""},{"location":"reference/simpyson/gui.html#simpyson.gui.SimpysonGUI","title":"SimpysonGUI","text":"<pre><code>SimpysonGUI()\n</code></pre> <p>               Bases: <code>QMainWindow</code></p> Source code in <code>simpyson/gui.py</code> <pre><code>def __init__(self):\n    super().__init__()\n    self.setWindowTitle(\"Simpyson GUI\")\n    self.setGeometry(100, 100, 1200, 800)\n\n    self.files_data = {}  # Dictionary to store {filename: data}\n    self.current_file = None\n    self.data = None\n    self.filename = None  # Added to store full path\n\n    self.init_ui()\n</code></pre>"},{"location":"reference/simpyson/gui.html#simpyson.gui.SimpysonGUI.combine_selected_spectra","title":"combine_selected_spectra","text":"<pre><code>combine_selected_spectra()\n</code></pre> <p>Combine multiple selected spectra into a single spectrum.</p> Source code in <code>simpyson/gui.py</code> <pre><code>def combine_selected_spectra(self):\n    \"\"\"Combine multiple selected spectra into a single spectrum.\"\"\"\n    if not (selected_items := self.get_selection()): \n        return\n\n    if len(selected_items) &lt; 2:\n        QMessageBox.warning(self, 'Combine Spectra', 'Please select at least two spectra to combine')\n        return\n\n    # Check that all selected items have spectrum data\n    for item in selected_items:\n        file_data = self.files_data[item.text()]['data']\n        if not file_data.spe:\n            QMessageBox.warning(self, 'Combine Spectra', \n                           f'{item.text()} is not in spectrum format. Convert all files to spectra first.')\n            return\n\n    # Collect all Simpy objects\n    spectra_list = [self.files_data[item.text()]['data'] for item in selected_items]\n\n    try:\n        # Combine spectra\n        combined = add_spectra(spectra_list)\n\n        # Create a new name for the combined spectrum\n        base_names = [item.text().split('.')[0] for item in selected_items]\n        new_name = f\"Combined_{'_'.join(base_names[:2])}\"\n        if len(base_names) &gt; 2:\n            new_name += f\"_plus{len(base_names)-2}\"\n        new_name += '.spe'\n\n        # Add to file list\n        self.files_data[new_name] = {\n            'data': combined,\n            'path': None,\n            'view': 'hz'\n        }\n\n        self.file_list.addItem(new_name)\n        new_item = self.file_list.findItems(new_name, Qt.MatchExactly)[0]\n        self.file_list.setCurrentItem(new_item)\n\n        QMessageBox.information(self, 'Combine Spectra', \n                           f'Successfully combined {len(spectra_list)} spectra')\n\n    except Exception as e:\n        QMessageBox.critical(self, 'Error', f'Failed to combine spectra: {str(e)}')\n</code></pre>"},{"location":"reference/simpyson/io.html","title":"io","text":""},{"location":"reference/simpyson/io.html#simpyson.io.read_csdf","title":"read_csdf","text":"<pre><code>read_csdf(filename, simpy_data)\n</code></pre> <p>This method reads NMR data from a SIMPSON CSDF file.</p> Source code in <code>simpyson/io.py</code> <pre><code>def read_csdf(filename, simpy_data):\n    \"\"\"\n    This method reads NMR data from a SIMPSON CSDF file.\n    \"\"\"\n    import csdmpy as cp\n    data = cp.load(filename)\n    hz = data.dimensions[0].coordinates.value\n    real = data.dependent_variables[0].components[0].real\n    imag = data.dependent_variables[0].components[0].imag\n    np_value = np.array(len(hz))\n    sw = np.abs(hz[-1] - hz[0])\n\n    simpy_data.from_csdf(real, imag, hz, np_value, sw)\n</code></pre>"},{"location":"reference/simpyson/io.html#simpyson.io.read_fid","title":"read_fid","text":"<pre><code>read_fid(filename, simpy_data)\n</code></pre> <p>This method reads NMR data from a SIMPSON FID file.</p> Source code in <code>simpyson/io.py</code> <pre><code>def read_fid(filename, simpy_data):\n    \"\"\"\n    This method reads NMR data from a SIMPSON FID file.\n    \"\"\"\n    with open(filename) as f:\n        data_sec = False\n        real = []\n        imag = []\n        for line in f:\n            if line.startswith('NP'):\n                np_value = float(line.split('=')[1])\n            elif line.startswith('SW'):\n                sw = float(line.split('=')[1])\n            elif line.startswith('DATA'):\n                data_sec = True\n            elif data_sec and line.startswith('END'):\n                break\n            elif data_sec:\n                a, b = map(float, line.split())\n                real.append(a)\n                imag.append(b)\n\n        dt = 1.0 / sw\n        time = np.linspace(0, np_value*dt, int(np_value))\n        real = np.array(real)\n        imag = np.array(imag)\n        time = np.array(time)*10e3\n\n        simpy_data.from_fid(real, imag, np_value, sw, time)\n</code></pre>"},{"location":"reference/simpyson/io.html#simpyson.io.read_simp","title":"read_simp","text":"<pre><code>read_simp(filename, format=None, b0=None, nucleus=None)\n</code></pre> <p>\" Reads Simpson's NMR data from a file into a unified Simpy object.</p> <p>Args:     filename: Path to the file     format: File format ('spe', 'fid', 'xreim') or None to guess from extension     b0: Magnetic field (e.g., '9.4T', '400MHz')     nucleus: Nucleus (e.g., '1H', '13C')</p> <p>Returns:     Simpy object with time- and frequency-domain data.</p> Source code in <code>simpyson/io.py</code> <pre><code>def read_simp(\n        filename,\n        format=None,\n        b0=None,\n        nucleus=None,\n):\n    \"\"\"\"\n    Reads Simpson's NMR data from a file into a unified Simpy object.\n\n    Args:\n        filename: Path to the file\n        format: File format ('spe', 'fid', 'xreim') or None to guess from extension\n        b0: Magnetic field (e.g., '9.4T', '400MHz')\n        nucleus: Nucleus (e.g., '1H', '13C')\n\n    Returns:\n        Simpy object with time- and frequency-domain data.\n        \"\"\"\n    # Try to guess format\n    ext = os.path.splitext(filename)[1].lower()\n    if ext == '.spe':\n        format = 'spe'\n    elif ext == '.fid':\n        format = 'fid'\n    elif ext == '.xreim':\n        format = 'xreim'\n    elif ext == '.csdf':\n        format = 'csdf'\n    else:\n        raise ValueError(f\"Cannot determine file format of {filename}\")\n\n    simpy_data = Simpy(b0=b0, nucleus=nucleus)\n\n    if format == 'spe':\n        read_spe(filename, simpy_data)\n    elif format == 'fid':\n        read_fid(filename, simpy_data)\n    elif format == 'xreim':\n        read_xreim(filename, simpy_data)\n    elif format == 'csdf':\n        read_csdf(filename, simpy_data)\n    else:\n        raise ValueError(f\"Unsupported format {format}\")\n    return simpy_data\n</code></pre>"},{"location":"reference/simpyson/io.html#simpyson.io.read_spe","title":"read_spe","text":"<pre><code>read_spe(filename, simpy_data)\n</code></pre> <p>This method reads NMR data from a SIMPSON SPE file.</p> Source code in <code>simpyson/io.py</code> <pre><code>def read_spe(filename, simpy_data):\n    \"\"\"\n    This method reads NMR data from a SIMPSON SPE file.\n    \"\"\"\n    with open(filename) as f:\n        data_sec = False\n        real = []\n        imag = []\n        for line in f:\n            if line.startswith('NP'):\n                np_value = float(line.split('=')[1])\n            elif line.startswith('SW'):\n                sw = float(line.split('=')[1])\n            elif line.startswith('DATA'):\n                data_sec = True\n            elif data_sec and line.startswith('END'):\n                break\n            elif data_sec:\n                a, b = map(float, line.split())\n                real.append(a)\n                imag.append(b)\n\n        hz = np.linspace(-int(sw) / 2, int(sw) / 2, int(np_value))\n\n        simpy_data.from_spe(real, imag, np_value, sw, hz)\n</code></pre>"},{"location":"reference/simpyson/io.html#simpyson.io.read_xreim","title":"read_xreim","text":"<pre><code>read_xreim(filename, simpy_data)\n</code></pre> <p>This method reads NMR data from a SIMPSON saved with -xreim option.</p> Source code in <code>simpyson/io.py</code> <pre><code>def read_xreim(filename, simpy_data):\n    \"\"\"\n    This method reads NMR data from a SIMPSON saved with -xreim option.\n    \"\"\"\n    with open(filename) as f:\n        time = []\n        real = []\n        imag = []\n        for line in f:\n            time.append(float(line.split()[0]))\n            real.append(float(line.split()[1]))\n            imag.append(float(line.split()[2]))\n\n        simpy_data.from_xreim(np.array(time), np.array(real), np.array(imag))\n</code></pre>"},{"location":"reference/simpyson/io.html#simpyson.io.write_simp","title":"write_simp","text":"<pre><code>write_simp(spinsys, out_name, out_format='.inp', spin_rate=10000.0, np=1024, proton_freq=400000000.0, start_op='Inx', detect_op='Inp', crystal_file='rep100', gamma_angles=4, sw=20000.0, verbose=0, lb=20, zerofill=4096, method='direct', **kwargs)\n</code></pre> <p>Create a SIMPSON input file with the specified parameters.</p> <p>Args:     spinsys: Spin system      out_name: Output file name     out_format: Output format     spin_rate: Spin rate in Hz     np: Number of points     proton_freq: Proton frequency in Hz     start_op: Start operator     detect_op: Detect operator     crystal_file: Crystal file     gamma_angles: Gamma angles     sw: Spectral width in Hz     verbose: Verbose output (0 or 1)     lb: Line broadening     zerofill: Zero filling     method: Simulation method (\"direct\", \"reduced\" etc.)     **kwargs: Additional parameters for Simpcalc</p> <p>Returns:     Simpcalc object that can be saved into a Simpson input file</p> Source code in <code>simpyson/io.py</code> <pre><code>def write_simp(spinsys, \n               out_name,\n               out_format=\".inp\",\n               spin_rate=10e3,\n               np=1024,\n               proton_freq=400e6,\n               start_op=\"Inx\",\n               detect_op=\"Inp\",\n               crystal_file=\"rep100\",\n               gamma_angles=4,\n               sw=20e3,\n               verbose=0,\n               lb=20,\n               zerofill=4096,\n               method=\"direct\", \n               **kwargs\n            ):\n    \"\"\"\n    Create a SIMPSON input file with the specified parameters.\n\n    Args:\n        spinsys: Spin system \n        out_name: Output file name\n        out_format: Output format\n        spin_rate: Spin rate in Hz\n        np: Number of points\n        proton_freq: Proton frequency in Hz\n        start_op: Start operator\n        detect_op: Detect operator\n        crystal_file: Crystal file\n        gamma_angles: Gamma angles\n        sw: Spectral width in Hz\n        verbose: Verbose output (0 or 1)\n        lb: Line broadening\n        zerofill: Zero filling\n        method: Simulation method (\"direct\", \"reduced\" etc.)\n        **kwargs: Additional parameters for Simpcalc\n\n    Returns:\n        Simpcalc object that can be saved into a Simpson input file\n    \"\"\"\n\n    # Create the Simpcalc object with all parameters\n    sim = Simpcalc(\n        spinsys=spinsys,\n        out_name=out_name,\n        out_format=out_format,\n        spin_rate=spin_rate,\n        np=np,\n        proton_freq=proton_freq,\n        start_op=start_op,\n        detect_op=detect_op,\n        crystal_file=crystal_file,\n        gamma_angles=gamma_angles,\n        sw=sw,\n        verbose=verbose,\n        lb=lb,\n        zerofill=zerofill,\n        method=method,\n        **kwargs\n    )\n\n    return sim \n</code></pre>"},{"location":"reference/simpyson/simpy.html","title":"simpy","text":""},{"location":"reference/simpyson/simpy.html#simpyson.simpy.Simpcalc","title":"Simpcalc","text":"<pre><code>Simpcalc(spinsys, out_name, out_format, spin_rate, np, proton_freq, start_op, detect_op, crystal_file, gamma_angles, sw, verbose, lb, zerofill, method='direct', tsw=None, pulse_sequence=None, pH=None, pX=None, pY=None, plH=None, plX=None, plY=None, phH=None, phX=None, phY=None)\n</code></pre> <p>Class to create a SIMPSON simulation input.</p> <p>Attributes:     spinsys (str): Spin system from Soprano or a custom string.     out_name (str): Output file name.     out_format (str): Output format (fid, spe, xreim).     spin_rate (float): Spin rate in Hz.     np (int): Number of points.     proton_freq (float): Proton frequency in Hz.     start_op (str): Start operator.     detect_op (str): Detect operator.     crystal_file (str): Crystal file.     gamma_angles (str): Gamma angles.     sw (float): Spectral width.     verbose (bool): Verbose output.     lb (float): Line broadening.     zerofill (int): Zero filling.     method (str): Method of simulation (direct, indirect, ...).     tsw (str, optional): Spectral width in time domain.     pulse_sequence (str, optional): Pulse sequence from templates or a custom string.     pH (float, optional): pulse for H in us.     pX (float, optional): pulse for X in us.     pY (float, optional): pulse for Y in us.     plH (float, optional): power level for H in Hz.     plX (float, optional): power level for X in Hz.     plY (float, optional): power level for Y in Hz.     phH (float, optional): phase for H pH.     phX (float, optional): phase for X pH.     phY (float, optional): phase for Y pH.</p> <p>Example:     sim = SimpSim(spinsys=spinsys, out_name='output', out_format='spe', spin_rate=15e3, np=2048, proton_freq=400e6, start_op='Inx', detect_op='Inp', crystal_file='rep100', gamma_angles=4, sw=20e3, verbose=0, lb=20, zerofill=4096)</p> Source code in <code>simpyson/simpy.py</code> <pre><code>def __init__(self, spinsys, out_name, out_format, spin_rate, np, proton_freq, start_op, detect_op, crystal_file, gamma_angles, sw, verbose, lb, zerofill, method=\"direct\", tsw=None, pulse_sequence=None, pH=None, pX=None, pY=None, plH=None, plX=None, plY=None, phH=None, phX=None, phY=None):\n    self.spin_rate = spin_rate\n    self.spinsys = spinsys\n    self.out_name = out_name\n    self.out_format = out_format\n    self.np = np\n    self.proton_freq = proton_freq\n    self.start_op = start_op\n    self.detect_op = detect_op\n    self.crystal_file = crystal_file\n    self.gamma_angles = gamma_angles\n    self.sw = sw\n    self.verbose = verbose\n    self.tsw = tsw if tsw else f\"1e6/{sw}\"\n    self.lb = lb\n    self.zerofill = zerofill\n    self.method = method\n    self.pulse_sequence = pulse_sequence\n    self.pH = pH\n    self.pX = pX\n    self.pY = pY\n    self.plH = plH\n    self.plX = plX\n    self.plY = plY\n    self.phH = phH\n    self.phX = phX\n    self.phY = phY\n</code></pre>"},{"location":"reference/simpyson/simpy.html#simpyson.simpy.Simpy","title":"Simpy","text":"<pre><code>Simpy(b0=None, nucleus=None)\n</code></pre> <p>A unified container Simpson NMR data that automatically handles conversions between formats.</p> <p>This class stores and manages Simpson's various formasts (FID, Spe in Hz and ppm) and  conversion between them.</p> <p>Attributes:     b0: Magnetic field (e.g., '9.4T', '400MHz')     nucleus: Nucleus type (e.g., '1H', '13C')</p> <p>Properties:     fid: Time-domain data     spe: Frequency-domain data (Hz)     ppm: Chemical shift data (ppm)</p> Source code in <code>simpyson/simpy.py</code> <pre><code>def __init__(self, b0=None, nucleus=None):\n    self._b0 = b0\n    self._nucleus = nucleus\n    self._fid_data = None  # Time-domain data\n    self._spe_data = None  # Frequency-domain data\n    self._xreim_data = None # xreim data\n    self._metadata = {}    \n</code></pre>"},{"location":"reference/simpyson/simpy.html#simpyson.simpy.Simpy.fid","title":"fid  <code>property</code>","text":"<pre><code>fid\n</code></pre> <p>Access time-domain data, converting from spectrum if needed.</p>"},{"location":"reference/simpyson/simpy.html#simpyson.simpy.Simpy.ppm","title":"ppm  <code>property</code>","text":"<pre><code>ppm\n</code></pre> <p>Access chemical shift data, computing from Hz if needed.</p>"},{"location":"reference/simpyson/simpy.html#simpyson.simpy.Simpy.spe","title":"spe  <code>property</code>","text":"<pre><code>spe\n</code></pre> <p>Access frequency-domain data, converting from FID if needed.</p>"},{"location":"reference/simpyson/simpy.html#simpyson.simpy.Simpy.xreim","title":"xreim  <code>property</code>","text":"<pre><code>xreim\n</code></pre> <p>Access xreim data.</p>"},{"location":"reference/simpyson/simpy.html#simpyson.simpy.Simpy.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Create a copy of a Simpy object.</p> Source code in <code>simpyson/simpy.py</code> <pre><code>def copy(self):\n    \"\"\"Create a copy of a Simpy object.\"\"\"\n    import copy as cp\n\n    new_obj = Simpy(b0=self._b0, nucleus=self._nucleus)\n\n    if self._fid_data is not None:\n        new_obj._fid_data = cp.deepcopy(self._fid_data)\n\n    if self._spe_data is not None:\n        new_obj._spe_data = cp.deepcopy(self._spe_data)\n\n    if self._xreim_data is not None:\n        new_obj._xreim_data = cp.deepcopy(self._xreim_data)\n\n    new_obj._metadata = cp.deepcopy(self._metadata)\n\n    return new_obj\n</code></pre>"},{"location":"reference/simpyson/simpy.html#simpyson.simpy.Simpy.from_csdf","title":"from_csdf","text":"<pre><code>from_csdf(real, imag, hz, np_value, sw)\n</code></pre> <p>Set data from CSDF values.</p> Source code in <code>simpyson/simpy.py</code> <pre><code>def from_csdf(self, real, imag, hz, np_value, sw):\n    \"\"\"Set data from CSDF values.\"\"\"\n\n    self._spe_data = {\n        'real': np.array(real),\n        'imag': np.array(imag),\n        'np': np_value,\n        'sw': sw,\n        'hz': np.array(hz)\n    }\n\n    if self._b0 and self._nucleus:\n        self._compute_ppm()\n\n    self._fid_data = None\n    return self\n</code></pre>"},{"location":"reference/simpyson/simpy.html#simpyson.simpy.Simpy.from_fid","title":"from_fid","text":"<pre><code>from_fid(real, imag, np_value, sw, time=None)\n</code></pre> <p>Set data from FID values.</p> Source code in <code>simpyson/simpy.py</code> <pre><code>def from_fid(self, real, imag, np_value, sw, time=None):\n    \"\"\"Set data from FID values.\"\"\"\n    if time is None:\n        dt = 1.0 / sw\n        time = np.linspace(0, np_value*dt, int(np_value)) * 10e3\n\n    self._fid_data = {\n        'real': np.array(real),\n        'imag': np.array(imag),\n        'np': np_value,\n        'sw': sw,\n        'time': np.array(time)\n    }\n\n    # Clear cached spectrum data\n    self._spe_data = None\n    return self\n</code></pre>"},{"location":"reference/simpyson/simpy.html#simpyson.simpy.Simpy.from_spe","title":"from_spe","text":"<pre><code>from_spe(real, imag, np_value, sw, hz=None)\n</code></pre> <p>Set data from spectrum values.</p> Source code in <code>simpyson/simpy.py</code> <pre><code>def from_spe(self, real, imag, np_value, sw, hz=None):\n    \"\"\"Set data from spectrum values.\"\"\"\n    if hz is None:\n        hz = np.linspace(-int(sw) / 2, int(sw) / 2, int(np_value))\n\n    self._spe_data = {\n        'real': np.array(real),\n        'imag': np.array(imag),\n        'np': np_value,\n        'sw': sw,\n        'hz': np.array(hz)\n    }\n\n    # Calculate ppm if possible\n    if self._b0 and self._nucleus:\n        self._compute_ppm()\n\n    # Clear cached FID data\n    self._fid_data = None\n    return self\n</code></pre>"},{"location":"reference/simpyson/simpy.html#simpyson.simpy.Simpy.from_xreim","title":"from_xreim","text":"<pre><code>from_xreim(time, real, imag)\n</code></pre> <p>Set data from xreim values.</p> Source code in <code>simpyson/simpy.py</code> <pre><code>def from_xreim(self, time, real, imag):\n    \"\"\"Set data from xreim values.\"\"\"\n\n    self._xreim_data = {\n        'time': np.array(time),\n        'real': np.array(real),\n        'imag': np.array(imag)\n    }\n\n    # Clear cached FID and spectrum data\n    self._fid_data = None\n    self._spe_data = None\n    return self\n</code></pre>"},{"location":"reference/simpyson/simpy.html#simpyson.simpy.Simpy.write","title":"write","text":"<pre><code>write(filename, format='csv')\n</code></pre> <p>Write data to file in specified format.</p> <p>Args:     filename: Output filename     format: Format to save as ('csv', 'fid', 'spe')</p> <p>Returns:     self for method chaining</p> Source code in <code>simpyson/simpy.py</code> <pre><code>def write(self, filename, format='csv'):\n    \"\"\"\n    Write data to file in specified format.\n\n    Args:\n        filename: Output filename\n        format: Format to save as ('csv', 'fid', 'spe')\n\n    Returns:\n        self for method chaining\n    \"\"\"\n    # CSV format\n    if format == 'csv':\n        if self.spe:\n            if 'ppm' in self.spe and self._b0 and self._nucleus:\n                x_data, x_label = self.spe['ppm'], 'ppm'\n            else:\n                x_data, x_label = self.spe['hz'], 'Hz'\n            y_data = self.spe['real']\n        elif self.fid:\n            x_data, x_label = self.fid['time'], 'Time (ms)'\n            y_data = self.fid['real']\n        elif self.xreim:\n            x_data, x_label = self.xreim['time'], 'Time (ms)'\n            y_data = self.xreim['real']\n        else:\n            raise ValueError(\"No data to save\")\n\n        np.savetxt(\n            filename,\n            np.column_stack((x_data, y_data)),\n            delimiter=\",\",\n            header=f\"{x_label},Real\",\n            comments=\"\"\n        )\n        return self\n\n    # SIMPSON formats\n    data_dict = None\n    if format == 'spe':\n        data_dict = self.spe\n        data_type = 'SPE'\n    elif format == 'fid':\n        data_dict = self.fid\n        data_type = 'FID'\n    elif format == 'xreim':\n        data_dict = self.xreim\n        data_type = 'XREIM'\n    else:\n        raise ValueError(f\"Unsupported save format: {format}\")\n\n    if not data_dict:\n        raise ValueError(f\"No data available to save in {format} format\")\n\n    # Write SIMPSON format file\n    with open(filename, 'w') as f:\n        f.write('SIMP\\n')\n        if 'np' in data_dict:\n            f.write(f'NP={data_dict[\"np\"]}\\n')\n        if 'sw' in data_dict:\n            f.write(f'SW={data_dict[\"sw\"]}\\n')\n        f.write(f'TYPE={data_type}\\n')\n        f.write('DATA\\n')\n\n        for re, im in zip(data_dict['real'], data_dict['imag']):\n            f.write(f'{re} {im}\\n')\n\n        f.write('END')\n\n    return self\n</code></pre>"},{"location":"reference/simpyson/templates.html","title":"templates","text":""},{"location":"reference/simpyson/utils.html","title":"utils","text":""},{"location":"reference/simpyson/utils.html#simpyson.utils.add_spectra","title":"add_spectra","text":"<pre><code>add_spectra(spectra_list, b0=None, nucleus=None)\n</code></pre> <p>Combine multiple Simpy objects into a single spectrum.</p> Source code in <code>simpyson/utils.py</code> <pre><code>def add_spectra(spectra_list, b0=None, nucleus=None):\n    \"\"\"Combine multiple Simpy objects into a single spectrum.\"\"\"\n    if not spectra_list:\n        return None\n\n    result = spectra_list[0].copy()\n\n    if b0:\n        result.b0 = b0\n    if nucleus:\n        result.nucleus = nucleus\n\n    for spectrum in spectra_list[1:]:\n        result._spe_data['real'] += spectrum.spe['real']\n        result._spe_data['imag'] += spectrum.spe['imag']\n\n    if result.b0 and result.nucleus:\n        result._compute_ppm()\n\n    return result\n</code></pre>"},{"location":"reference/simpyson/utils.html#simpyson.utils.get_larmor_freq","title":"get_larmor_freq","text":"<pre><code>get_larmor_freq(b0, nucleus, isotope_file=None)\n</code></pre> <p>Convert Hz values to ppm values.</p> <p>Args:     b0 (str): Magnetic field strength (e.g., '400MHz' or '9.4T')     nucleus (str): Nucleus type (e.g., '1H' or '13C')     isotope_file (str, optional): Path to isotope data file. If None, uses default.</p> <p>Returns:     float: Larmor Frequency</p> <p>Raises:     ValueError: If B0 unit is invalid or nucleus not found</p> Source code in <code>simpyson/utils.py</code> <pre><code>def get_larmor_freq(b0, nucleus, isotope_file=None):\n    \"\"\"\n    Convert Hz values to ppm values.\n\n    Args:\n        b0 (str): Magnetic field strength (e.g., '400MHz' or '9.4T')\n        nucleus (str): Nucleus type (e.g., '1H' or '13C')\n        isotope_file (str, optional): Path to isotope data file. If None, uses default.\n\n    Returns:\n        float: Larmor Frequency\n\n    Raises:\n        ValueError: If B0 unit is invalid or nucleus not found\n    \"\"\"\n\n    if isotope_file is None:\n        dir = os.path.dirname(os.path.realpath(__file__))\n        isotope_file = os.path.join(dir, 'isotope_data.json')\n\n    isotope = int(''.join(filter(str.isdigit, nucleus)))\n    element = ''.join(filter(str.isalpha, nucleus)).capitalize()\n    b0_unit = ''.join(filter(str.isalpha, b0)).lower()\n\n    with open(isotope_file) as f:\n        data = json.load(f)\n        if element in data and str(isotope) in data[element]:\n            gamma = data[element][str(isotope)]['Gamma']\n        else:\n            raise ValueError(f'Nucleus {nucleus} not found in isotope data.')\n\n    if b0_unit == 't':\n        b0_value = float(''.join(filter(lambda x: x.isdigit() or x == '.', b0)))\n        larmor_freq = gamma * 1e7 * b0_value / (2 * np.pi * 1e6)\n        ppm = hz / np.abs(larmor_freq)\n    elif b0_unit == 'mhz':\n        b0_value = float(''.join(filter(lambda x: x.isdigit() or x == '.', b0))) \n        gamma_h = data['H']['1']['Gamma']\n        b0_value_T = 2 * np.pi * b0_value * 1e6 / (gamma_h * 1e7)\n        larmor_freq = gamma * 1e7 * b0_value_T / (2 * np.pi * 1e6)\n    else:\n        raise ValueError('B0 unit must be T or MHz.')\n\n    return larmor_freq\n</code></pre>"},{"location":"user_guide/read_files.html","title":"Read Simpson files","text":"<pre><code>from simpyson.io import read_simp\nimport matplotlib.pyplot as plt\nimport numpy as np\n</code></pre> <pre><code># Read a FID file\ndata = read_simp('../../examples/read/ethanol.fid')\n\n# Access the FID data through the fid property\nfid_data = data.fid\nfor key, value in fid_data.items():\n    if isinstance(value, np.ndarray) and len(value) &amp;gt; 5:\n        print(f\"{key}: array with {len(value)} points, first 5: {value[:5]}\")\n    else:\n        print(f\"{key}: {value}\")\n</code></pre> <pre>\n<code>real: array with 4096 points, first 5: [95.9999136  63.5468932  20.9678205  15.3255165   7.47400991]\nimag: array with 4096 points, first 5: [ 0.        52.0761046 48.2650021 34.3591044 39.1643879]\nnp: 4096.0\nsw: 10000.0\ntime: array with 4096 points, first 5: [0.        1.0002442 2.0004884 3.0007326 4.0009768]\n</code>\n</pre> <pre><code>plt.figure(figsize=(10, 5))\nplt.plot(data.fid['time'], data.fid['real'], label='Real')\nplt.plot(data.fid['time'], data.fid['imag'], label='Imaginary')\nplt.xlabel('Time (ms)')\nplt.ylabel('Intensity')\nplt.title('Free Induction Decay (FID)')\nplt.legend()\nplt.grid(True, alpha=0.3)\nplt.show()\n</code></pre> <pre><code># Read a SPE file\nspe_data = read_simp('../../examples/read/ethanol.spe')\n\n# Examine the spectrum data\nfor key, value in spe_data.spe.items():\n    if isinstance(value, np.ndarray) and len(value) &amp;gt; 5:\n        print(f\"{key}: array with {len(value)} points, first 5: {value[:5]}\")\n    else:\n        print(f\"{key}: {value}\")\n</code></pre> <pre>\n<code>real: array with 4096 points, first 5: [0.18006085 0.19032725 0.1798519  0.19019057 0.17964413]\nimag: array with 4096 points, first 5: [-20.1918974 -20.1791859 -20.0945303 -20.0819291 -19.9973317]\nnp: 4096.0\nsw: 10000.0\nhz: array with 4096 points, first 5: [-5000.         -4997.55799756 -4995.11599512 -4992.67399267\n -4990.23199023]\n</code>\n</pre> <pre><code>plt.figure(figsize=(10, 5))\nplt.plot(spe_data.spe['hz'], spe_data.spe['real'])\nplt.xlabel('Frequency (Hz)')\nplt.ylabel('Intensity')\nplt.title('\u00b9H NMR Spectrum of Ethanol')\nplt.xlim(3000, 0)  # Reverse x-axis to match conventional NMR display\nplt.grid(True, alpha=0.3)\nplt.show()\n</code></pre> <pre><code># Read spectrum with B\u2080 and nucleus specified\nspe_ppm = read_simp('../../examples/read/ethanol.spe', b0='400MHz', nucleus='1H')\n\n# Access the ppm data through the ppm property\nplt.figure(figsize=(10, 5))\nplt.plot(spe_ppm.ppm['ppm'], spe_ppm.ppm['real'])\nplt.xlabel('Chemical Shift (ppm)')\nplt.ylabel('Intensity')\nplt.title('\u00b9H NMR Spectrum of Ethanol')\nplt.xlim(8, 0)  # Conventional ppm range for \u00b9H\nplt.grid(True, alpha=0.3)\nplt.show()\n</code></pre> <pre><code># Read a FID file\nfid_data = read_simp('../../examples/read/ethanol.fid')\n\n# Access the spectrum data - automatic FID\u2192SPE conversion happens here\nauto_converted_spe = fid_data.spe\n\n# Compare with directly loaded SPE file\nspe_data = read_simp('../../examples/read/ethanol.spe')\n\nplt.figure(figsize=(10, 5))\nplt.plot(auto_converted_spe['hz'], auto_converted_spe['real'], label='Auto-converted from FID')\nplt.plot(spe_data.spe['hz'], spe_data.spe['real'], label='Directly loaded SPE')\nplt.xlim(3000, 0)\nplt.xlabel('Frequency (Hz)')\nplt.ylabel('Intensity')\nplt.title('Comparison of Spectrum Data')\nplt.legend()\nplt.grid(True, alpha=0.3)\nplt.show()\n</code></pre> <p>Similarly, if you load a spectrum file but need FID data, access the <code>fid</code> property for automatic conversion:</p> <pre><code># Access FID data from a loaded spectrum file - automatic conversion happens\nauto_converted_fid = spe_data.fid\n\nplt.figure(figsize=(10, 5))\nplt.plot(auto_converted_fid['time'], auto_converted_fid['real'], label='Auto-converted from SPE')\nplt.plot(fid_data.fid['time'], fid_data.fid['real'], label='Directly loaded FID')\nplt.xlabel('Time (ms)')\nplt.ylabel('Intensity')\nplt.title('Comparison of FID Data')\nplt.legend()\nplt.grid(True, alpha=0.3)\nplt.show()\n</code></pre> <pre><code># Export as CSV\nfid_data.write('../../examples/read/exported_fid.csv', format='csv')\n\n# Export as SIMPSON FID file\nfid_data.write('../../examples/read/exported.fid', format='fid')\n\n# Export as SIMPSON SPE file\nspe_data.write('../../examples/read/exported.spe', format='spe')\n\nprint(\"Files exported successfully!\")\n</code></pre> <pre>\n<code>Files exported successfully!\n</code>\n</pre>"},{"location":"user_guide/read_files.html#read-simpson-files-with-simpyson","title":"Read SIMPSON files with SimPYson","text":""},{"location":"user_guide/read_files.html#introduction","title":"Introduction","text":"<p>SimPYson provides a unified interface to read and work with SIMPSON NMR data.  In the <code>examples</code> folder, you can find various SIMPSON files:</p> <ul> <li><code>ethanol.in</code>: A standard input file for a SIMPSON simulation of the ethanol molecule</li> <li><code>ethanol.fid</code>: The simulated free induction decay (FID) of the ethanol molecule</li> <li><code>ethanol.spe</code>: The NMR spectrum of the ethanol molecule</li> </ul> <p>The <code>read_simp()</code> function reads SIMPSON files into a unified <code>Simpy</code> object that handles conversions between formats automatically.</p>"},{"location":"user_guide/read_files.html#the-simpy-object","title":"The Simpy object","text":"<p>The <code>Simpy</code> class provides a unified interface for working with Simpson NMR data in various formats. Its key features are:</p> <ul> <li>Reading SIMPSON files (FID, SPE, XREIM)</li> <li>Automatically convert between time and frequency domains</li> <li>Convert Hz to ppm when magnetic field (<code>B0</code>) and nucleus (e.g. <code>1H</code>) are provided</li> <li>Export data to SIMPSON formats and csv</li> </ul>"},{"location":"user_guide/read_files.html#reading-fid-files","title":"Reading FID files","text":"<p>Let's start by reading a FID file. The <code>read_simp()</code> function automatically detects the file format from its extension.</p>"},{"location":"user_guide/read_files.html#plotting-fid-data","title":"Plotting FID data","text":"<p>The FID data can be easily plotted using matplotlib:</p>"},{"location":"user_guide/read_files.html#reading-spe-files","title":"Reading SPE files","text":"<p>When reading a spectrum (SPE) file, data is accessible through the <code>spe</code> property:</p>"},{"location":"user_guide/read_files.html#plotting-spectrum-data","title":"Plotting Spectrum Data","text":"<p>The \u00b9H NMR spectrum of ethanol shows three distinct \u00b9H NMR peaks:</p> <ul> <li>A triplet from the CH\u2083 group</li> <li>A quartet from the CH\u2082 group</li> <li>A singlet from the OH group</li> </ul> <p>You can edit the J-coupling parameters in the <code>examples/ethanol.in</code> file to see the effect on peak splitting.</p>"},{"location":"user_guide/read_files.html#converting-to-chemical-shift-ppm","title":"Converting to Chemical Shift (ppm)","text":"<p>To display the spectrum in chemical shift (ppm) units, provide the magnetic field (<code>b0</code>) and nucleus type when reading the file. The ppm scale is automatically calculated:</p>"},{"location":"user_guide/read_files.html#automatic-format-conversion","title":"Automatic Format Conversion","text":"<p>One of the key features of the new <code>Simpy</code> class is automatic format conversion. If you load a FID file but need spectrum data, simply access the <code>spe</code> property and the conversion happens automatically:</p>"},{"location":"user_guide/read_files.html#exporting-data","title":"Exporting Data","text":"<p>The <code>Simpy</code> class provides a built-in <code>write()</code> method to export data in various formats:</p>"},{"location":"user_guide/write_simpson.html","title":"Prepare Simpson simulations","text":"<p>A Simpson input file is typically divided into four main sections:</p> <ol> <li>Spin System: This section identifies the nuclei to be simulated and includes their NMR parameters, such as isotropic shift, asymmetry, and Euler angles.</li> <li>Parameters: This defines the settings for the \"virtual spectrometer,\" such as the magnetic field strength (<code>proton_freq</code>), spinning rate (<code>spin_rate</code>), number of points (<code>np</code>), pulse lengths, pulse powers, etc.</li> <li>Pulse Sequence: This part specifies the pulse program used in the simulation.</li> <li>Processing: Defines the processing parameters, such as line broadening (<code>lb</code>) or Fourier transformation of the FID signal.</li> </ol> <p>Simpyson simplifies the preparation of these input files by interfacing data from DFT calculations with Simpson, using ASE. The spin system for magres files from CASTEP and Quantum Espresso NMR calculations can be easily generated with Soprano, while Simpyson can handle the rest of the input file.</p> <p>For a more detailed description of each parameter, please refer to the following Simpson papers Bak et al, To\u0161ner et al., and Juhl et al.</p> <pre><code>from soprano.calculate.nmr.simpson import write_spinsys\nfrom ase.io import read\nfrom simpyson.converter import read_vasp\nfrom simpyson.templates import no_pulse\nfrom simpyson.io import read_simp, write_simp\nfrom simpyson.utils import add_spectra\nimport matplotlib.pyplot as plt\n</code></pre> <p>In the following example, we start by reading the structure from an ethanol CASTEP calculation, selecting the H atoms, referencing the chemical shifts (<code>grad = {'H' : -1}</code> and <code>ref = {'H' : 31.7}</code>), and construct the input file for a spectrum acquired at 400 MHz (<code>spin_rate = 40e3</code>) with a spinning rate of 40 kHz (<code>spin_rate = 40e3</code>). To keep the simulation simple, we begin with the magnetization in the xy-plane (<code>start_op = 'Inx'</code>), i.e. the detection plane, thus removing the need to due pulses. For this, we can use the <code>no_pulse</code> sequence.</p> <pre><code># Read magres file\nethanol = read('../../examples/write/ethanol.magres')\n\n# Select only the H atoms\nh_idx = [atom.index for atom in ethanol if atom.symbol == 'H']\nH_subset = ethanol[h_idx]\n\n# Get spin system\nspinsys = write_spinsys(H_subset,\n            use_ms = True,\n            grad = {'H' : -1},\n            ref = {'H' : 31.7})\n\n# Prepare Simpson simulation using write_simp\nsimp_in = write_simp(\n    spinsys = spinsys,\n    out_name = 'ethanol_sim',\n    out_format = 'spe',\n    spin_rate = 40e3,\n    np = 2048,\n    proton_freq = 400e6,\n    start_op = 'Inx',\n    detect_op = 'Inp',\n    crystal_file = 'rep256',\n    gamma_angles = 6,\n    sw = 10e3,\n    verbose = '01',\n    lb = 10,\n    zerofill = 4096,\n    method = \"direct\",\n    tsw = 1e4,\n    pulse_sequence = no_pulse,\n)\n\n# Write input file\nsimp_in.save('../../examples/write/ethanol_sim.in')\n</code></pre> <pre>\n<code>&lt;simpyson.simpy.Simpcalc at 0x20d8356ed50&gt;</code>\n</pre> <p>The results can be easily plotted. The difference between this spectrum and the one from the previous tutorial is due to the absence of J-coupling in this simulation.</p> <pre><code># Read using read_simp instead of SimpReader\nethanol_out = read_simp('../../examples/write/ethanol_sim.spe', format='spe', b0='400MHz', nucleus='1H')\n\n# Access ppm data through property\nplt.plot(ethanol_out.ppm['x'], ethanol_out.ppm['real'])\nplt.xlim(8, 0)\nplt.xlabel('$^1$H (ppm)')\nplt.show()\n</code></pre> <p>Unlike CASTEP and Quantum Espresso <code>magres</code> files, VASP's OUTCAR file contains the magnetic shielding and electric field gradient tensors in units that are not in Hz, as required by Soprano and Simpson. Additionally, ASE's read function doesn't automatically add the <code>ms</code> and <code>efg</code> arrays to the <code>Atoms</code> object, which are necessary for Soprano to prepare the spin system. The <code>read_vasp</code> function handles these conversions and adds the required information. Here is one example how to use it, and how the results compare with a similar CASTEP calculation.</p> <pre><code># Castep calculation\ncastep = read('../../examples/write/AlPO-14.magres')\n\np_idx = [atom.index for atom in castep if atom.symbol == 'P']\np_subset = castep[p_idx]\nal_idx = [atom.index for atom in castep if atom.symbol == 'Al']\nal_subset = castep[al_idx]\n\np_spinsys = write_spinsys(p_subset,\n            use_ms = True,\n            grad = {'P' : -1},\n            ref = {'P' : 283.839})\n\n\n# Al is a quadrupolar so it is important to consider the quadrupolar interaction\n# Simpson allows simulation of quadrupolar broadening up to 2nd order\nal_spinsys = write_spinsys(al_subset,\n            use_ms = True,\n            grad = {'Al' : -1},\n            ref = {'Al' : 538.78},\n            q_order=2)\n\np_inp = write_simp(\n    spinsys = p_spinsys,\n    out_name = 'castep_sim_p',\n    out_format = 'spe',\n    spin_rate = 40e3,\n    np = 2048,\n    proton_freq = 800e6,\n    start_op = 'Inx',\n    detect_op = 'Inp',\n    crystal_file = 'rep168',\n    gamma_angles = 6,\n    sw = 30e3,\n    verbose = '01',\n    lb = 200,\n    zerofill = 4096,\n    method = \"direct\",\n    tsw = 3e4,\n    pulse_sequence = no_pulse,\n)\n\nal_inp = write_simp(\n    spinsys = al_spinsys,\n    out_name = 'castep_sim_al',\n    out_format = 'spe',\n    spin_rate = 40e3,\n    np = 2048,\n    proton_freq = 800e6,\n    start_op = 'Inx',\n    detect_op = 'Inc',\n    crystal_file = 'rep168',\n    gamma_angles = 6,\n    sw = 20e3,\n    verbose = '01',\n    lb = 200,\n    zerofill = 4096,\n    method = \"direct\",\n    tsw = 2e4,\n    pulse_sequence = no_pulse,\n)\n\np_inp.save('../../examples/write/castep_sim_p.in')\nal_inp.save('../../examples/write/castep_sim_al.in')\n\n\n# VASP calculation\nvasp = read_vasp('../../examples/write/AlPO-14.OUTCAR', format='vasp-out')\n\np_idx = [atom.index for atom in vasp if atom.symbol == 'P']\np_subset = vasp[p_idx]\nal_idx = [atom.index for atom in vasp if atom.symbol == 'Al']\nal_subset = vasp[al_idx]\n\np_spinsys = write_spinsys(p_subset,\n            use_ms = True,\n            grad = {'P' : -1},\n            ref = {'P' : 294.50})\n\nal_spinsys = write_spinsys(al_subset,\n            use_ms = True,\n            grad = {'Al' : -1},\n            ref = {'Al' : 542.96},\n            q_order=2)\n\np_inp = write_simp(\n    spinsys = p_spinsys,\n    out_name = 'vasp_sim_p',\n    out_format = 'spe',\n    spin_rate = 40e3,\n    np = 2048,\n    proton_freq = 800e6,\n    start_op = 'Inx',\n    detect_op = 'Inp',\n    crystal_file = 'rep168',\n    gamma_angles = 6,\n    sw = 30e3,\n    verbose = '01',\n    lb = 200,\n    zerofill = 4096,\n    method = \"direct\",\n    tsw = 3e4,\n    pulse_sequence = no_pulse,\n)\n\nal_inp = write_simp(\n    spinsys = al_spinsys,\n    out_name = 'vasp_sim_al',\n    out_format = 'spe',\n    spin_rate = 40e3,\n    np = 2048,\n    proton_freq = 800e6,\n    start_op = 'Inx',\n    detect_op = 'Inc',\n    crystal_file = 'rep168',\n    gamma_angles = 6,\n    sw = 20e3,\n    verbose = '01',\n    lb = 200,\n    zerofill = 4096,\n    method = \"direct\",\n    tsw = 2e4,\n    pulse_sequence = no_pulse,\n)\n\np_inp.save('../../examples/write/vasp_sim_p.in')\nal_inp.save('../../examples/write/vasp_sim_al.in')\n</code></pre> <pre>\n<code>&lt;simpyson.simpy.Simpcalc at 0x20d836cd610&gt;</code>\n</pre> <p>Unless you have a laptop/node with crazy amounts of memory, simulating the full Al spin system, containing 8 Al atoms each with second-order quadrupolar broadening <code>q_order = 2</code>, can be quite challenging. Since we're not considering coupling between the Al atoms, a more efficient approach is to prepare an input file for each individual Al atom and then merge all the spectra into a combined spectrum. This reduces the computational load and makes the simulation much more manageable.</p> <pre><code># Prepare Simpson for each Al atom of CASTEP\nal_idx = [atom.index for atom in castep if atom.symbol == 'Al']\n\nfor i, atom in enumerate(al_idx):\n    al_subset = castep[[atom]]\n    al_spinsys = write_spinsys(al_subset,\n                use_ms = True,\n                grad = {'Al' : -1},\n                ref = {'Al' : 538.78},\n                q_order=2)\n\n    al_inp = write_simp(\n        spinsys = al_spinsys,\n        out_name = f'castep_sim_al_{i}',\n        out_format = 'spe',\n        spin_rate = 40e3,\n        np = 2048,\n        proton_freq = 800e6,\n        start_op = 'Inx',\n        detect_op = 'Inc',\n        crystal_file = 'rep168',\n        gamma_angles = 6,\n        sw = 20e3,\n        verbose = '01',\n        lb = 200,\n        zerofill = 4096,\n        method = \"direct\",\n        tsw = 2e4,\n        pulse_sequence = no_pulse,\n    )\n\n    al_inp.save(f'../../examples/write/split_simulation_al/castep_sim_al_{i}.in')\n\n# Prepare Simpson for each Al atom of VASP\nal_idx = [atom.index for atom in vasp if atom.symbol == 'Al']\n\nfor i, atom in enumerate(al_idx):\n    al_subset = vasp[[atom]]\n    al_spinsys = write_spinsys(al_subset,\n                use_ms = True,\n                grad = {'Al' : -1},\n                ref = {'Al' : 542.96},\n                q_order=2)\n\n    al_inp = write_simp(\n        spinsys = al_spinsys,\n        out_name = f'vasp_sim_al_{i}',\n        out_format = 'spe',\n        spin_rate = 40e3,\n        np = 2048,\n        proton_freq = 800e6,\n        start_op = 'Inx',\n        detect_op = 'Inc',\n        crystal_file = 'rep168',\n        gamma_angles = 6,\n        sw = 20e3,\n        verbose = '01',\n        lb = 200,\n        zerofill = 4096,\n        method = \"direct\",\n        tsw = 2e4,\n        pulse_sequence = no_pulse,\n    )\n\n    al_inp.save(f'../../examples/write/split_simulation_al/vasp_sim_al_{i}.in')\n</code></pre> <p>Now let's combined all the <sup>27</sup>Al spectra and plot the results.</p> <pre><code># Read CASTEP 27Al simulations one by one\ncastep_al_spectra = []\nfor i in range(len(al_idx)):\n    castep_al_spectra.append(read_simp(\n        f'../../examples/write/split_simulation_al/castep_sim_al_{i}.spe', \n        format='spe', \n        b0='800MHz', \n        nucleus='27Al'\n    ))\n\n# Combine all spectra using add_spectra\ncastep_al_out = add_spectra(castep_al_spectra)\n\n# Read CASTEP 31P simulation\ncastep_p_out = read_simp('../../examples/write/castep_sim_p.spe', format='spe', b0='800MHz', nucleus='31P')\n\n# Do the same for VASP\nvasp_al_spectra = []\nfor i in range(len(al_idx)):\n    vasp_al_spectra.append(read_simp(\n        f'../../examples/write/split_simulation_al/vasp_sim_al_{i}.spe',\n        format='spe',\n        b0='800MHz',\n        nucleus='27Al'\n    ))\n\nvasp_al_out = add_spectra(vasp_al_spectra)\n\nvasp_p_out = read_simp('../../examples/write/vasp_sim_p.spe', format='spe', b0='800MHz', nucleus='31P')\n\n# Plot the spectra\nfig, ax = plt.subplots(1, 2, figsize=(10, 5))\nax[0].plot(castep_p_out.ppm['x'], castep_p_out.ppm['real'])\nax[0].plot(vasp_p_out.ppm['x'], vasp_p_out.ppm['real'])\nax[0].set_xlabel('$^{31}$P (ppm)')\nax[0].set_xlim(-10, -45)\nax[0].legend(['CASTEP', 'VASP'])\nax[1].plot(castep_al_out.ppm['x'], castep_al_out.ppm['real'])\nax[1].plot(vasp_al_out.ppm['x'], vasp_al_out.ppm['real'])\nax[1].set_xlabel('$^{27}$Al (ppm)')\nax[1].set_xlim(45, 0)\nax[1].legend(['CASTEP', 'VASP'])\nplt.show()\n</code></pre>"},{"location":"user_guide/write_simpson.html#write-simpson-simulations","title":"Write Simpson simulations","text":""},{"location":"user_guide/write_simpson.html#read-vasp-nmr-calculations","title":"Read VASP NMR calculations","text":""}]}